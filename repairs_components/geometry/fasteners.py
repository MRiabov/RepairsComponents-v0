"""Fastener components like screws, bolts, and nuts.

This module provides fastener components that can be used with the Genesis physics simulator.
Genesis supports MJCF (MuJoCo) format for model definition, allowing for easy migration
from MuJoCo-based simulations.
"""

from __future__ import annotations

from typing import TYPE_CHECKING

from repairs_components.logic.tools.tool import ToolsEnum
from repairs_components.training_utils.sim_state_global import (
    RepairsSimInfo,
    RepairsSimState,
)

if TYPE_CHECKING:  # circular dep.
    from repairs_components.logic.tools.tools_state import ToolState
from dataclasses import dataclass, field
from pathlib import Path

import genesis as gs
import torch
from build123d import *
from genesis.engine.entities import RigidEntity
from ocp_vscode import show

from repairs_components.geometry.base import Component
from repairs_components.processing.geom_utils import get_connector_pos


@dataclass
class Fastener(Component):
    """Fastener class. All values are in millimeters (mm)."""

    # Declare fields so TensorClass/dataclass know expected attributes
    initial_hole_id_a: int | None = None
    """ID of the hole for constraint A"""
    initial_hole_id_b: int | None = None
    """ID of the hole for constraint B"""
    # note: initial_hole_a and b are not used in bd geometry.
    length: float = 15.0
    """Fastener length (mm)"""
    diameter: float = 5.0
    """Fastener shank diameter (mm)"""
    expected_body_name_a: str | None = None
    """Optional: Name of the body for constraint A. If provided, constraint mechanism can check hole IDs correspond to body IDs and names."""
    expected_body_name_b: str | None = None
    """Optional: Name of the body for constraint B. If provided, constraint mechanism can check hole IDs correspond to body IDs and names."""
    b_depth: float = 5.0
    """Engagement depth on body B (mm)"""
    head_diameter: float = 7.5
    """Fastener head diameter (mm)"""
    head_height: float = 3.0
    """Fastener head height (mm)"""
    thread_pitch: float = 0.5
    """Thread pitch (mm)"""
    b_constraint_active: bool = field(
        default=False,
        init=False,
    )
    """Deprecated/back-compat: True if initial_hole_id_b is provided"""
    name: str = field(
        default="",
        init=False,
    )
    """Autogenerated fastener name based on diameter and length"""

    def __post_init__(self) -> None:
        """Validate dimensions and derive computed fields."""
        assert self.head_diameter > self.diameter, (
            "head_diameter of a fastener must be greater than diameter"
        )
        assert self.b_depth > 0, "b_depth of a fastener must be greater than 0"
        # self.a_constraint_active = True # note: a_constraint_active is always True now.
        self.b_constraint_active = (
            self.initial_hole_id_b is not None
        )  # deprecated, for backwards compatibility
        self.name = get_fastener_singleton_name(self.diameter, self.length)

    def get_mjcf(self):
        """Get MJCF of a screw. MJCF is preferred because it is faster and more reliable than meshes.

        Args:
            thread_pitch: Distance between threads in mm.
            length: Total length of the screw in mm.
            diameter: Outer diameter of the screw thread in mm.
            head_diameter: Diameter of the screw head in mm.
            head_height: Height of the screw head in mm.
        """
        # MJCF expects meters, Build123d uses mm, so convert mm to m
        shaft_radius = self.diameter / 2 / 1000
        shaft_length = self.length / 1000
        head_radius = self.head_diameter / 2 / 1000
        head_height = self.head_height / 1000
        # Head base at z=0, head centered at head_height/2, shaft centered at -shaft_length/2
        # Tip body at z=-shaft_length
        return f"""
    <mujoco>
    <worldbody>
        <body name="{self.name}">
            <!-- <joint name="{self.name}_base_joint" type="weld"/> -->
            <geom name="{self.name}_head" type="cylinder"
                  size="{head_radius} {head_height / 2}"
                  pos="0 0 {head_height / 2}"
                  rgba="0.5 0.5 0.5 1"
                  density="7800"/>

            <geom name="{self.name}_shaft" type="cylinder"
                  size="{shaft_radius} {shaft_length / 2}"
                  pos="0 0 {-shaft_length / 2}"
                  rgba="0.8 0.8 0.8 1"
                  density="7800"/>

            <body name="{self.name}_tip" pos="0 0 {-shaft_length}">
                <!-- Tip is located at the end of the shaft (z=-shaft_length) -->
                <site name="{self.name}_tip_site" pos="0 0 0" size="0.001" rgba="1 0 0 1"/>
            </body>
        </body>
    </worldbody>
    </mujoco>
"""

    def bd_geometry(self) -> Part:
        """Create a build123d geometry for the fastener.

        Returns:
            A build123d Solid representing the screw with shaft and head.
        """
        from build123d import BuildPart, Cylinder, Vector

        with BuildPart() as fastener:
            # Use Vector and cast to float to handle potential TensorClass tensors
            with Locations(Vector(0, 0, -float(self.length) / 2)):
                # Create the shaft (main cylinder)
                shaft = Cylinder(
                    radius=self.diameter / 2,  # Convert diameter to radius
                    height=float(self.length),
                )

            # Create the head (wider cylinder)
            with Locations(Vector(0, 0, float(self.head_height) / 2)):
                head = Cylinder(
                    radius=self.head_diameter / 2,  # Convert diameter to radius
                    height=float(self.head_height),
                )
            head.faces().filter_by(Axis.Z).sort_by(Axis.Z).last

            RigidJoint(
                "fastener_joint_a",
                joint_location=shaft.faces()
                .filter_by(Axis.Z)
                .sort_by(Axis.Z)
                .last.center_location,
            )  # lowest point of head/top of shaft (top of shaft because there were rotation issues)
            RigidJoint(
                "fastener_joint_b",
                joint_location=shaft.faces()
                .filter_by(Axis.Z)
                .sort_by(Axis.Z)
                .last.offset(amount=-self.b_depth)
                .center_location,
            )  # lowest point of the head + offset
            RigidJoint(
                "fastener_joint_tip",
                joint_location=fastener.faces()
                .filter_by(Axis.Z)
                .sort_by(Axis.Z)
                .first.center_location,
            )  # lowest point of the fastener

        fastener = fastener.part
        fastener.color = Color(0.58, 0.44, 0.86, 0.8)
        fastener.label = self.name

        # # set collision detection position at the tip of the fastener
        # fastener_collision_detection_position = tuple(
        #     shaft.faces().sort_by(Axis.Z).last.center()
        # )

        return fastener

    @staticmethod
    def get_tip_pos_relative_to_center(length: float | torch.Tensor = 15.0 / 1000):
        if isinstance(length, torch.Tensor):
            assert length.ndim == 1
            tip_pos = torch.zeros(
                length.shape[0], 3, dtype=torch.float32, device=length.device
            )
            tip_pos[:, 2] = -length
            return tip_pos
        return torch.tensor([0, 0, -length])
        # note: fastener head relative to center is a pointless function because 1mm offset or whatnot is insignificant.

    @staticmethod
    def fastener_name_in_simulation(fastener_id_in_genesis: int):
        """Return the name of a fastener that is used in the genesis simulation. Note that
        this is not the name of the fastener in build123d, but the name of the fastener
        in the genesis simulation."""
        return f"{fastener_id_in_genesis}@fastener"
        # the inverse is int(fastener_name.split("@")[0]), it's spinkled throughout the code.


def check_fastener_possible_insertion(
    scene: gs.Scene,
    sim_state: RepairsSimState,
    sim_info: RepairsSimInfo,
    connection_dist_threshold: float = 0.75,  # meters (!)
    connection_angle_threshold: torch.Tensor = torch.full(
        (1,), 30
    ),  # either [1] or [B]  # degrees
    ignore_part_idx: torch.Tensor | None = None,  # [B]
    env_ids: torch.Tensor | None = None,  # [B]
) -> tuple[torch.Tensor, torch.Tensor]:
    """
    Check if a currently picked up fastener can be inserted.
    Args:
    - env_ids: [B] tensor of environment indices.
    - connection_threshold: float
    - ignore_part_idx: torch.Tensor, indices of the part to ignore (if fastener is already inserted in that part in that batch, ignore.) [B]

    Batch check: for each env, find first hole within threshold or -1. If part_hole_quats is not None, check that the hole is not rotated too much.
    Returns:
    - Tuple of tensors `(part_idx, hole_idx)`, each of shape `[batch]`, where `-1` indicates no match and value >= 0 indicates the hole index, with its part index.
    """
    from repairs_components.processing.geom_utils import are_quats_within_angle

    dist = torch.norm(
        sim_state.physical_state.hole_positions
        - sim_state.tool_state.screwdriver_tc.picked_up_fastener_tip_position,
        dim=-1,
    )  # [B, H]
    # ignore holes that this fastener is already attached to
    if ignore_part_idx is not None:
        assert ignore_part_idx.shape == (
            sim_state.physical_state.hole_positions.shape[0],
        ), (
            f"ignore_part_idx must be a 1D tensor of shape [B], got {ignore_part_idx.shape}"
        )
        mask = ignore_part_idx != -1
        batch_idx = torch.arange(len(ignore_part_idx), device=ignore_part_idx.device)[
            mask
        ]
        part_idx = ignore_part_idx[mask]
        dist[batch_idx, part_idx] = float("inf")

    # mask out holes that are not within angle threshold

    angle_mask = are_quats_within_angle(
        sim_state.physical_state.hole_quats,
        sim_state.tool_state.screwdriver_tc.picked_up_fastener_quat,
        connection_angle_threshold,
    )
    dist[~angle_mask] = float("inf")
    # find the closest hole
    hole_min = torch.min(dist, dim=-1)
    # if it's close enough, return the hole index
    close_enough = hole_min.values < connection_dist_threshold  # [B]
    # if it's not close enough, return -1
    hole_idx = torch.where(close_enough, hole_min.indices, -1)
    part_idx = torch.where(
        hole_idx != -1,
        sim_info.physical_info.part_hole_batch[hole_idx],
        torch.full_like(hole_idx, -1),
    )

    return part_idx, hole_idx


def attach_fastener_to_screwdriver(
    scene: gs.Scene,
    sim_state: RepairsSimState,
    sim_info: RepairsSimInfo,
    fastener_id: torch.Tensor,  # tensor [B]
    env_ids: torch.Tensor | None,  # [B]
):
    """Attach a fastener to the screwdriver using IDs.

    Args:
        scene: Genesis scene.
        sim_state: Batched simulation state. Used to update screwdriver tool state.
        sim_info: Singleton metadata. Used to resolve Genesis base link indices.
        fastener_id: Integer IDs of the fastener to attach (batched).
        env_ids: Tensor of environment indices [B] to which this operation applies.

    Behavior:
        - Computes screwdriver grip pose for env_ids.
        - Aligns fastener base link to screwdriver and adds a weld constraint.
        - Writes picked up fastener position, orientation and ID into `sim_state.tool_state.screwdriver_tc`.
    """
    # avoid circular import
    from repairs_components.logic.tools.screwdriver import Screwdriver

    if env_ids is None:
        env_ids = torch.arange(scene.n_envs, device=sim_state.device)
    B = env_ids.shape[0]
    assert fastener_id.shape == env_ids.shape, "Fastener id is meant to be batched."
    rigid_solver = scene.sim.rigid_solver
    # Normalize dtypes/shapes for Genesis API
    env_ids_i32 = env_ids.to(torch.int32)
    fastener_head_joint = sim_info.physical_info.fastener_base_link_idx[fastener_id].to(
        torch.int32
    )
    screwdriver_link_idx = int(
        sim_info.tool_info.tool_base_link_idx[ToolsEnum.SCREWDRIVER.value]
    )
    screwdriver_links = torch.full(
        (B,), screwdriver_link_idx, dtype=torch.int32, device=env_ids_i32.device
    )
    # compute screwdriver grip position for the base link only -> shape [3]
    screwdriver_xyz = sim_state.physical_state.tool_pos[
        env_ids, ToolsEnum.SCREWDRIVER.value
    ]
    screwdriver_quat = sim_state.physical_state.tool_quat[
        env_ids, ToolsEnum.SCREWDRIVER.value
    ]
    rel_vec = Screwdriver.fastener_connector_pos_relative_to_center().expand(
        screwdriver_xyz.shape[0], -1
    )
    grip_pos = get_connector_pos(screwdriver_xyz, screwdriver_quat, rel_vec)
    # calc fastener offset
    fasteners_offset = torch.zeros(
        (sim_info.physical_info.fasteners_length.shape[0], 3),
        dtype=torch.float32,
        device=sim_info.physical_info.fastener_base_link_idx.device,
    )
    fasteners_offset[:, 2] = sim_info.physical_info.fasteners_length

    fastener_tip_pos = get_connector_pos(
        screwdriver_xyz,
        screwdriver_quat,
        Fastener.get_tip_pos_relative_to_center().expand(screwdriver_xyz.shape[0], -1),
    )

    # Align the fastener before constraining: set pose for the target fastener links
    rigid_solver.set_base_links_pos(grip_pos, fastener_head_joint, env_ids_i32)
    rigid_solver.set_base_links_quat(screwdriver_quat, fastener_head_joint, env_ids_i32)
    # Idempotent: remove any existing weld before adding
    rigid_solver.delete_weld_constraint(
        fastener_head_joint, screwdriver_links, env_ids_i32
    )  # FIXME: but this should never happen as we ignore it!
    rigid_solver.add_weld_constraint(
        fastener_head_joint, screwdriver_links, env_ids_i32
    )  # works in genesis examples.
    sim_state.tool_state.screwdriver_tc.picked_up_fastener_tip_position[env_ids] = (
        fastener_tip_pos
    )
    sim_state.tool_state.screwdriver_tc.picked_up_fastener_quat[env_ids] = (
        screwdriver_quat
    )
    # Also store numeric id for batched processing; use int with -1 sentinel for none
    sim_state.tool_state.screwdriver_tc.picked_up_fastener_id[env_ids] = fastener_id


def detach_fastener_from_screwdriver(
    scene: gs.Scene,
    sim_state: RepairsSimState,
    sim_info: RepairsSimInfo,
    env_ids: torch.Tensor | None = None,  # [B]
):
    """Detach the currently attached fastener from the screwdriver over env_ids.

    Args:
        scene: Genesis scene.
        sim_state: Batched simulation state. Used to clear screwdriver tool state.
        sim_info: Singleton metadata. Used to resolve Genesis base link indices.
        fastener_id: Integer ID of the fastener to detach.
        env_ids: Tensor of environment indices [B].

    Side effects:
        - Removes weld constraint fastener<->screwdriver for env_ids.
        - Clears picked-up fastener pose and sets picked_up_fastener_id to -1 in tool state.
    """
    assert (
        sim_state.tool_state.tool_ids[env_ids] == ToolsEnum.SCREWDRIVER.value
    ).all(), "Tool must be a Screwdriver"
    assert sim_state.tool_state.screwdriver_tc.has_picked_up_fastener.all(), (
        "Expected all env_ids to have a picked up fastener!"
    )
    if env_ids is None:
        env_ids = torch.arange(scene.n_envs)
    env_ids_i32 = env_ids.to(torch.int32)
    rigid_solver = scene.sim.rigid_solver
    picked_up_fastener_ids = sim_state.tool_state.screwdriver_tc.picked_up_fastener_id[
        env_ids_i32
    ]
    # Delete weld between fastener head and screwdriver base link
    screwdriver_link_idx = int(
        sim_info.tool_info.tool_base_link_idx[ToolsEnum.SCREWDRIVER.value]
    )
    screwdriver_links = torch.full(
        (int(env_ids_i32.shape[0]),),
        screwdriver_link_idx,
        dtype=torch.int32,
        device=env_ids_i32.device,
    )
    fastener_head_link = sim_info.physical_info.fastener_base_link_idx[
        picked_up_fastener_ids
    ].to(torch.int32)
    rigid_solver.delete_weld_constraint(
        fastener_head_link, screwdriver_links, env_ids_i32
    )  # works in genesis examples.
    sim_state.tool_state.screwdriver_tc.picked_up_fastener_tip_position[env_ids] = (
        torch.nan
    )
    sim_state.tool_state.screwdriver_tc.picked_up_fastener_quat[env_ids] = torch.nan
    sim_state.tool_state.screwdriver_tc.picked_up_fastener_id[env_ids] = -1
    return sim_state


def attach_picked_up_fastener_to_part(
    scene: gs.Scene,
    sim_state: RepairsSimState,
    sim_info: RepairsSimInfo,
    inserted_into_hole_ids: torch.Tensor,  # [B], int
    top_hole_id: torch.Tensor,  # [B], int
    envs_idx: torch.Tensor,
):
    """Attach the picked up fastener to a part by IDs and add a weld constraint.

    ID-based API. All geometry and parameters are resolved internally from `physical_state`
    and `physical_info` using the provided IDs.

    Args:
        scene: Genesis scene.
        physical_state: Batched `PhysicalState` providing current hole poses.
        physical_info: Singleton `PhysicalStateInfo` providing hole metadata and link indices.
        fastener_id: Tensor [B] of fastener IDs for each env in `envs_idx`.
        inserted_into_hole_ids: Tensor [B] of hole IDs (indices into hole arrays) to attach into.
        top_hole_id: Tensor [B] of the already-connected hole ID for the same fastener in the
            same env, or -1 if none. When not -1, must refer to a through hole.
        envs_idx: Tensor [B] of environment indices to apply the update to.

    Behavior:
        - Computes target fastener position with `recalculate_fastener_pos_with_offset_to_hole(...)`
          using hole depth/through flags and remaining length if partially inserted from the top.
        - Sets orientation equal to the target hole quaternion.
        - Adds a weld constraint between fastener base link and the owning body base link.

    Notes:
        - Shapes must match B = len(envs_idx). No implicit broadcasting.
        - Units are meters.
        - Preconditions (asserted):
            * If top_hole_id != -1 -> `hole_is_through[top_hole_id]` must be True.
            * `fasteners_length[fastener_id] > 0`.
            * `inserted_into_hole_ids` must be in range [0, H).
    """
    assert inserted_into_hole_ids.shape == top_hole_id.shape == envs_idx.shape, (
        "Batching failure"
    )
    # Validate input tensor shapes match env batch size
    B = int(envs_idx.shape[0])
    assert envs_idx.ndim == 1 and B > 0, "envs_idx must be 1D with length > 0"

    # Validate hole id ranges
    physical_info = sim_info.physical_info
    H = int(physical_info.part_hole_batch.shape[0])
    assert ((inserted_into_hole_ids >= 0) & (inserted_into_hole_ids < H)).all(), (
        f"inserted_into_hole_ids out of range [0,{H})"
    )
    assert ((top_hole_id == -1) | ((top_hole_id >= 0) & (top_hole_id < H))).all(), (
        f"top_hole_id must be -1 (none) or in [0,{H})"
    )
    picked_up_fastener_id = sim_state.tool_state.screwdriver_tc.picked_up_fastener_id[
        envs_idx
    ]

    # Where a top hole is specified, it must be through
    has_top = top_hole_id != -1
    if has_top.any():
        assert physical_info.hole_is_through[top_hole_id[has_top]].all(), (
            "Top hole must be through when specified"
        )
    physical_state = sim_state.physical_state

    inserted_into_part_id = physical_info.part_hole_batch[inserted_into_hole_ids]

    rigid_solver = scene.sim.rigid_solver
    fastener_links = physical_info.fastener_base_link_idx[picked_up_fastener_id]
    other_body_links = physical_info.body_base_link_idx[inserted_into_part_id]

    # Prepare top_hole_depth: zero where top_hole_id == -1 (no top insertion)
    top_depth = torch.zeros_like(
        inserted_into_hole_ids, dtype=physical_info.hole_depth.dtype
    )
    has_top_mask = top_hole_id != -1
    top_depth[has_top_mask] = physical_info.hole_depth[top_hole_id[has_top_mask]]

    # Select per-env hole pose using advanced indexing [B, 3] / [B, 4]
    hole_pos_env = physical_state.hole_positions[envs_idx, inserted_into_hole_ids]
    hole_quat_env = physical_state.hole_quats[envs_idx, inserted_into_hole_ids]

    fastener_pos = recalculate_fastener_pos_with_offset_to_hole(
        hole_pos_env,
        hole_quat_env,
        physical_info.hole_depth[inserted_into_hole_ids],
        physical_info.hole_is_through[inserted_into_hole_ids],
        physical_info.fasteners_length[picked_up_fastener_id],
        top_depth,
    )

    scene.rigid_solver.set_base_links_pos(fastener_pos, fastener_links, envs_idx)
    scene.rigid_solver.set_base_links_quat(hole_quat_env, fastener_links, envs_idx)

    # Make idempotent: remove existing weld if present before adding
    rigid_solver.delete_weld_constraint(fastener_links, other_body_links, envs_idx)
    rigid_solver.add_weld_constraint(
        fastener_links, other_body_links, envs_idx
    )  # works in genesis's examples.
    # FIXME: rigid weld constraint would make screwing the other part impossible. it should be a circular joint first.


def detach_fastener_from_part(
    scene: gs.Scene,
    sim_state: RepairsSimState,
    sim_info: RepairsSimInfo,
    part_ids: torch.Tensor,
    envs_idx: torch.Tensor,
):
    assert envs_idx.shape == part_ids.shape, "Improper batching."
    rigid_solver = scene.sim.rigid_solver
    picked_up_fastener_id = sim_state.tool_state.screwdriver_tc.picked_up_fastener_id[
        envs_idx
    ]
    fastener_head_joint = sim_info.physical_info.fastener_base_link_idx[
        picked_up_fastener_id
    ]
    other_body_hole_link = sim_info.physical_info.body_base_link_idx[part_ids]
    rigid_solver.delete_weld_constraint(
        fastener_head_joint, other_body_hole_link, envs_idx
    )  # works in genesis's examples.
    # set as fasteners as detached
    sim_state.physical_state.fasteners_attached_to_body[
        envs_idx, picked_up_fastener_id, :
    ] = -1
    sim_state.physical_state.fasteners_attached_to_hole[
        envs_idx, picked_up_fastener_id, :
    ] = -1

    return sim_state


class FastenerHolder(Component):
    fastener_sizes_held: torch.Tensor  # float 1D tensor of fastener sizes held

    # so, should each body hold fasteners? heterogenous graph?
    # no, simply create a "count_loose_fasteners_inside" as an integer and node feature and fasteners
    # will be constrained.

    # and the fastener holder is a specialty component for holding loose fasteners.

    # so if fasteners are loose, how do we reconstruct them? Probably SAVE the fasteners metadata to bodies graph.
    # however it is not used in `x`.

    def __init__(self, name: str, fastener_sizes_held: torch.Tensor):
        super().__init__(name)
        self.fastener_sizes_held = fastener_sizes_held
        self.count_fasteners_held = torch.nonzero(fastener_sizes_held).shape[0]

    def bd_geometry():
        # TODO: copy bd_geometry from tooling stand... tooling stand kind of is the fastener holder.
        raise NotImplementedError


# NOTE: see https://github.com/Genesis-Embodied-AI/Genesis/blob/main/examples/rigid/suction_cup.py for rigid constraint added in time

# To remove A/B constraint and activate screwdriver constraint
# model.eq_active[model.equality(name_to_id(model, "equality", f"{name}_to_ab"))] = 0
# model.eq_active[model.equality(name_to_id(model, "equality", f"{name}_to_screwdriver"))] = 1


def get_fastener_singleton_name(diameter: float, length: float) -> str:
    """Return the name for a fastener singleton based on its diameter and length."""
    diameter_str = f"{diameter:.2f}"
    length_str = f"{length:.2f}"
    return f"fastener_d{diameter_str}_l{length_str}@fastener"


def get_fastener_params_from_name(name: str) -> tuple[float, float]:
    """Return the diameter and lengthF of a fastener singleton based on its name."""
    diameter_str = name.split("_")[1][1:]  # [1:] - remove 'd'
    length_str = name.split("_")[2][1:]  # [1:] - remove 'h'
    length_str = length_str.split("@")[0]  # remove everything after '@'
    return float(diameter_str), float(length_str)


def get_singleton_fastener_save_path(
    diameter: float, length: float, base_dir: Path
) -> Path:
    """Return the save path for a fastener singleton based on its diameter and length."""
    return (
        base_dir
        / "shared"
        / "fasteners"
        / f"fastener_d{diameter:.2f}_h{length:.2f}.xml"
    )


def get_fastener_save_path_from_name(name: str, base_dir: Path) -> Path:
    """Return the save path for a fastener singleton based on its name."""
    return base_dir / "shared" / "fasteners" / (name + ".xml")


def recalculate_fastener_pos_with_offset_to_hole(
    hole_pos: torch.Tensor,  # [B, 3]
    hole_quat: torch.Tensor,  # [B, 4]
    hole_depth: torch.Tensor,  # [B] - always positive
    hole_is_through: torch.Tensor,  # [B] - boolean mask
    fastener_length: torch.Tensor,  # [B]
    top_hole_depth: torch.Tensor,  # [B] # zero or positive
):
    """Handle three cases:
    1. Attaching a free fastener to a through hole, so connect the top of the fastener
    at the top of the hole
    2. Attaching a free fastener to a non-through (blind) hole, so connect the bottom
    of the fastener at the bottom of the hole
    3. Attaching a fastener partially inserted into a through hole, so top_hole_depth
    is not None, so connect the bottom (B) hole to the center of the fastener.
    - in the third case, the remaining length to be accommodated by the bottom hole is
      (fastener_length - top_hole_depth). Therefore, offset along the hole axis by
      (fastener_length - top_hole_depth), i.e. (hole_pos + (fastener_length - top_hole_depth))@quat.
    - in the third case, the hole_pos, hole_quat and hole_depth are params of a bottom hole.
    - in the third case, the fastener inserted into a blind hole can not be connected nowhere else.
    """
    assert hole_depth >= 0, "Hole depth must be positive."
    assert top_hole_depth >= 0, "top_hole_depth must be positive or zero."
    assert fastener_length > top_hole_depth, (
        "fastener_length must be greater than top_hole_depth."
    )

    through_hole = hole_is_through
    has_partial_insertion = top_hole_depth > 0

    # Start with hole_pos for all cases
    fastener_pos = hole_pos.clone()

    # Case 1: Through hole without partial insertion - fastener_pos = hole_pos (no offset)
    # This is already handled by starting with hole_pos.clone()

    # Case 2: Blind hole without partial insertion - offset by (fastener_length - hole_depth)
    blind_hole_no_partial = ~through_hole & ~has_partial_insertion
    if blind_hole_no_partial.any():
        # For blind holes, we need to offset the fastener position
        # The offset should be applied in the hole's coordinate system (using quaternion)
        offset = torch.zeros_like(hole_pos)
        offset[blind_hole_no_partial, 2] = (fastener_length - hole_depth)[
            blind_hole_no_partial
        ]

        # Apply quaternion transformation using get_connector_pos
        transformed_pos = get_connector_pos(
            hole_pos[blind_hole_no_partial],
            hole_quat[blind_hole_no_partial],
            offset[blind_hole_no_partial],
        )
        fastener_pos[blind_hole_no_partial] = transformed_pos

    # Case 3: Partial insertion - offset by the remaining length (L - top_hole_depth)
    # (applies to both through and blind holes for the second connection)
    if has_partial_insertion.any():
        # For partial insertion, offset by the depth the fastener is already inserted
        offset = torch.zeros_like(hole_pos)
        offset[has_partial_insertion, 2] = (fastener_length - top_hole_depth)[
            has_partial_insertion
        ]

        # Apply quaternion transformation using get_connector_pos
        transformed_pos = get_connector_pos(
            hole_pos[has_partial_insertion],
            hole_quat[has_partial_insertion],
            offset[has_partial_insertion],
        )
        fastener_pos[has_partial_insertion] = transformed_pos

    return fastener_pos


if __name__ == "__main__":
    show(Fastener().bd_geometry())
