"""A module of completely autogenerated tests for geom_utils.py."""

import torch
import pytest
import math
from repairs_components.processing.geom_utils import (
    get_connector_pos,
    quat_multiply,
    quat_conjugate,
    quat_angle_diff_deg,
    are_quats_within_angle,
    sanitize_quaternion,
    euler_deg_to_quat_wxyz,
    quaternion_delta,
)


# -----------------------------------------------
# === get_connector_pos tests ===
# -----------------------------------------------


def test_get_connector_pos_identity_quaternion():
    """Test get_connector_pos with identity quaternion (no rotation)."""
    parent_pos = torch.tensor([[1.0, 2.0, 3.0]])  # [B, 3]
    parent_quat = torch.tensor([[1.0, 0.0, 0.0, 0.0]])  # [B, 4] - identity quaternion
    rel_connector_pos = torch.tensor([[0.5, 0.0, 0.0]])  # [B, 3]

    result = get_connector_pos(parent_pos, parent_quat, rel_connector_pos)
    expected = torch.tensor([[1.5, 2.0, 3.0]])  # parent_pos + rel_connector_pos

    assert torch.allclose(result, expected, atol=1e-6)


def test_get_connector_pos_90_degree_y_rotation():
    """Test get_connector_pos with 90-degree rotation around Y-axis."""
    parent_pos = torch.tensor([[0.0, 0.0, 0.0]])  # [B, 3]
    # 90-degree rotation around Y-axis: [cos(45°), 0, sin(45°), 0]
    parent_quat = torch.tensor(
        [[math.cos(math.pi / 4), 0.0, math.sin(math.pi / 4), 0.0]]
    )  # [B, 4]
    rel_connector_pos = torch.tensor([[1.0, 0.0, 0.0]])  # [B, 3] - along X-axis

    result = get_connector_pos(parent_pos, parent_quat, rel_connector_pos)
    # After 90° Y rotation, X becomes -Z (due to the specific quaternion rotation direction)
    expected = torch.tensor([[0.0, 0.0, -1.0]])

    assert torch.allclose(result, expected, atol=1e-6)


def test_get_connector_pos_batch():
    """Test get_connector_pos with multiple batch elements."""
    parent_pos = torch.tensor([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]])  # [B=2, 3]
    parent_quat = torch.tensor([[1.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0]])  # [B=2, 4]
    rel_connector_pos = torch.tensor([[1.0, 0.0, 0.0], [0.0, 1.0, 0.0]])  # [B=2, 3]

    result = get_connector_pos(parent_pos, parent_quat, rel_connector_pos)
    expected = torch.tensor([[2.0, 0.0, 0.0], [0.0, 2.0, 0.0]])

    assert torch.allclose(result, expected, atol=1e-6)


# -----------------------------------------------
# === quat_multiply tests ===
# -----------------------------------------------


def test_quat_multiply_identity():
    """Test quaternion multiplication with identity quaternions."""
    q1 = torch.tensor([[1.0, 0.0, 0.0, 0.0]])  # identity
    q2 = torch.tensor([[1.0, 0.0, 0.0, 0.0]])  # identity

    result = quat_multiply(q1, q2)
    expected = torch.tensor([[1.0, 0.0, 0.0, 0.0]])

    assert torch.allclose(result, expected, atol=1e-6)


def test_quat_multiply_90_degree_rotations():
    """Test quaternion multiplication of 90-degree rotations."""
    # 90-degree rotation around X-axis
    q1 = torch.tensor([[math.cos(math.pi / 4), math.sin(math.pi / 4), 0.0, 0.0]])
    # 90-degree rotation around Y-axis
    q2 = torch.tensor([[math.cos(math.pi / 4), 0.0, math.sin(math.pi / 4), 0.0]])

    result = quat_multiply(q1, q2)

    # Result should be normalized
    assert torch.allclose(torch.norm(result, dim=-1), torch.tensor([1.0]), atol=1e-6)


def test_quat_multiply_no_normalize():
    """Test quaternion multiplication without normalization."""
    q1 = torch.tensor([[2.0, 0.0, 0.0, 0.0]])  # not normalized
    q2 = torch.tensor([[1.0, 0.0, 0.0, 0.0]])  # identity

    result = quat_multiply(q1, q2, normalize=False)
    expected = torch.tensor([[2.0, 0.0, 0.0, 0.0]])

    assert torch.allclose(result, expected, atol=1e-6)


def test_quat_multiply_batch():
    """Test quaternion multiplication with batch inputs."""
    q1 = torch.tensor([[1.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0]])
    q2 = torch.tensor([[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0]])

    result = quat_multiply(q1, q2)
    expected = torch.tensor([[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0]])

    assert torch.allclose(result, expected, atol=1e-6)


# -----------------------------------------------
# === quat_conjugate tests ===
# -----------------------------------------------


def test_quat_conjugate_identity():
    """Test conjugate of identity quaternion."""
    q = torch.tensor([[1.0, 0.0, 0.0, 0.0]])
    result = quat_conjugate(q)
    expected = torch.tensor([[1.0, 0.0, 0.0, 0.0]])  # conjugate of identity is identity

    assert torch.allclose(result, expected, atol=1e-6)


def test_quat_conjugate_general():
    """Test conjugate of general quaternion."""
    q = torch.tensor([[0.5, 0.5, 0.5, 0.5]])
    result = quat_conjugate(q)
    expected = torch.tensor([[0.5, -0.5, -0.5, -0.5]])

    assert torch.allclose(result, expected, atol=1e-6)


def test_quat_conjugate_batch():
    """Test conjugate with batch inputs."""
    q = torch.tensor([[1.0, 0.0, 0.0, 0.0], [0.5, 0.5, 0.5, 0.5]])
    result = quat_conjugate(q)
    expected = torch.tensor([[1.0, 0.0, 0.0, 0.0], [0.5, -0.5, -0.5, -0.5]])

    assert torch.allclose(result, expected, atol=1e-6)


# -----------------------------------------------
# === quat_angle_diff_deg tests ===
# -----------------------------------------------


def test_quat_angle_diff_deg_identical():
    """Test angle difference between identical quaternions."""
    q1 = torch.tensor([[1.0, 0.0, 0.0, 0.0]])
    q2 = torch.tensor([[1.0, 0.0, 0.0, 0.0]])

    result = quat_angle_diff_deg(q1, q2)
    expected = torch.tensor([0.0])

    assert torch.allclose(result, expected, atol=1e-6)


def test_quat_angle_diff_deg_90_degrees():
    """Test angle difference for 90-degree rotation."""
    q1 = torch.tensor([[1.0, 0.0, 0.0, 0.0]])  # identity
    q2 = torch.tensor(
        [[math.cos(math.pi / 4), math.sin(math.pi / 4), 0.0, 0.0]]
    )  # 90° around X

    result = quat_angle_diff_deg(q1, q2)
    expected = torch.tensor([90.0])

    assert torch.allclose(result, expected, atol=1e-4)


def test_quat_angle_diff_deg_180_degrees():
    """Test angle difference for 180-degree rotation."""
    q1 = torch.tensor([[1.0, 0.0, 0.0, 0.0]])  # identity
    q2 = torch.tensor([[0.0, 1.0, 0.0, 0.0]])  # 180° around X

    result = quat_angle_diff_deg(q1, q2)
    expected = torch.tensor([180.0])

    assert torch.allclose(result, expected, atol=1e-4)


def test_quat_angle_diff_deg_batch():
    """Test angle difference with batch inputs."""
    q1 = torch.tensor([[1.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0]])
    q2 = torch.tensor(
        [[1.0, 0.0, 0.0, 0.0], [math.cos(math.pi / 4), math.sin(math.pi / 4), 0.0, 0.0]]
    )

    result = quat_angle_diff_deg(q1, q2)
    expected = torch.tensor([0.0, 90.0])

    assert torch.allclose(result, expected, atol=1e-4)


# -----------------------------------------------
# === are_quats_within_angle tests ===
# -----------------------------------------------


def test_are_quats_within_angle_true():
    """Test quaternions within angle threshold."""
    q1 = torch.tensor([[1.0, 0.0, 0.0, 0.0]])  # identity
    q2 = torch.tensor(
        [[math.cos(math.pi / 8), math.sin(math.pi / 8), 0.0, 0.0]]
    )  # 45° around X
    max_angle_deg = torch.tensor([50.0])

    result = are_quats_within_angle(q1, q2, max_angle_deg)
    expected = torch.tensor([True])

    assert torch.equal(result, expected)


def test_are_quats_within_angle_false():
    """Test quaternions outside angle threshold."""
    q1 = torch.tensor([[1.0, 0.0, 0.0, 0.0]])  # identity
    q2 = torch.tensor(
        [[math.cos(math.pi / 4), math.sin(math.pi / 4), 0.0, 0.0]]
    )  # 90° around X
    max_angle_deg = torch.tensor([45.0])

    result = are_quats_within_angle(q1, q2, max_angle_deg)
    expected = torch.tensor([False])

    assert torch.equal(result, expected)


def test_are_quats_within_angle_batch():
    """Test are_quats_within_angle with batch inputs."""
    q1 = torch.tensor([[1.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0]])
    q2 = torch.tensor(
        [
            [math.cos(math.pi / 8), math.sin(math.pi / 8), 0.0, 0.0],
            [math.cos(math.pi / 4), math.sin(math.pi / 4), 0.0, 0.0],
        ]
    )  # 45°, 90°
    max_angle_deg = torch.tensor([50.0, 50.0])

    result = are_quats_within_angle(q1, q2, max_angle_deg)
    expected = torch.tensor([True, False])

    assert torch.equal(result, expected)


# -----------------------------------------------
# === sanitize_quaternion tests ===
# -----------------------------------------------


def test_sanitize_quaternion_valid():
    """Test sanitize_quaternion with valid normalized quaternion."""
    q = torch.tensor([[1.0, 0.0, 0.0, 0.0]])
    result = sanitize_quaternion(q)

    assert torch.allclose(result, q, atol=1e-6)


def test_sanitize_quaternion_tuple_input():
    """Test sanitize_quaternion with tuple input."""
    q = (1.0, 0.0, 0.0, 0.0)
    result = sanitize_quaternion(q)
    expected = torch.tensor([1.0, 0.0, 0.0, 0.0])

    assert torch.allclose(result, expected, atol=1e-6)


def test_sanitize_quaternion_wrong_shape():
    """Test sanitize_quaternion with wrong shape."""
    q = torch.tensor([[1.0, 0.0, 0.0]])  # only 3 elements

    with pytest.raises(AssertionError, match="Expected last dimension to be 4"):
        sanitize_quaternion(q)


def test_sanitize_quaternion_not_normalized():
    """Test sanitize_quaternion with non-normalized quaternion."""
    q = torch.tensor([[2.0, 0.0, 0.0, 0.0]])  # norm = 2.0

    with pytest.raises(AssertionError, match="Quaternion norm deviates from 1"):
        sanitize_quaternion(q)


def test_sanitize_quaternion_nan():
    """Test sanitize_quaternion with NaN values."""
    q = torch.tensor([[float("nan"), 0.0, 0.0, 0.0]])

    with pytest.raises(AssertionError, match="Quaternion contains NaN or Inf"):
        sanitize_quaternion(q)


def test_sanitize_quaternion_inf():
    """Test sanitize_quaternion with infinite values."""
    q = torch.tensor([[float("inf"), 0.0, 0.0, 0.0]])

    with pytest.raises(AssertionError, match="Quaternion contains NaN or Inf"):
        sanitize_quaternion(q)


def test_sanitize_quaternion_batch():
    """Test sanitize_quaternion with batch inputs."""
    q = torch.tensor([[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0]])
    result = sanitize_quaternion(q)

    assert torch.allclose(result, q, atol=1e-6)


# -----------------------------------------------
# === euler_deg_to_quat_wxyz tests ===
# -----------------------------------------------


def test_euler_deg_to_quat_wxyz_zero():
    """Test Euler to quaternion conversion with zero angles."""
    euler_deg = torch.tensor([[0.0, 0.0, 0.0]])
    result = euler_deg_to_quat_wxyz(euler_deg)
    expected = torch.tensor([[1.0, 0.0, 0.0, 0.0]])  # identity quaternion

    assert torch.allclose(result, expected, atol=1e-6)


def test_euler_deg_to_quat_wxyz_90_x():
    """Test Euler to quaternion conversion with 90° roll (X-axis)."""
    euler_deg = torch.tensor([[90.0, 0.0, 0.0]])
    result = euler_deg_to_quat_wxyz(euler_deg)
    expected = torch.tensor([[math.cos(math.pi / 4), math.sin(math.pi / 4), 0.0, 0.0]])

    assert torch.allclose(result, expected, atol=1e-6)


def test_euler_deg_to_quat_wxyz_90_y():
    """Test Euler to quaternion conversion with 90° pitch (Y-axis)."""
    euler_deg = torch.tensor([[0.0, 90.0, 0.0]])
    result = euler_deg_to_quat_wxyz(euler_deg)
    expected = torch.tensor([[math.cos(math.pi / 4), 0.0, math.sin(math.pi / 4), 0.0]])

    assert torch.allclose(result, expected, atol=1e-6)


def test_euler_deg_to_quat_wxyz_90_z():
    """Test Euler to quaternion conversion with 90° yaw (Z-axis)."""
    euler_deg = torch.tensor([[0.0, 0.0, 90.0]])
    result = euler_deg_to_quat_wxyz(euler_deg)
    expected = torch.tensor([[math.cos(math.pi / 4), 0.0, 0.0, math.sin(math.pi / 4)]])

    assert torch.allclose(result, expected, atol=1e-6)


def test_euler_deg_to_quat_wxyz_normalized():
    """Test that Euler to quaternion conversion returns normalized quaternions."""
    euler_deg = torch.tensor([[45.0, 30.0, 60.0]])
    result = euler_deg_to_quat_wxyz(euler_deg)

    # Check normalization
    norm = torch.norm(result, dim=-1)
    assert torch.allclose(norm, torch.tensor([1.0]), atol=1e-6)


def test_euler_deg_to_quat_wxyz_wrong_shape():
    """Test Euler to quaternion conversion with wrong input shape."""
    euler_deg = torch.tensor([[0.0, 0.0]])  # only 2 elements

    with pytest.raises(AssertionError, match="Expected last dimension to be 3"):
        euler_deg_to_quat_wxyz(euler_deg)


def test_euler_deg_to_quat_wxyz_batch():
    """Test Euler to quaternion conversion with batch inputs."""
    euler_deg = torch.tensor([[0.0, 0.0, 0.0], [90.0, 0.0, 0.0]])
    result = euler_deg_to_quat_wxyz(euler_deg)
    expected = torch.tensor(
        [[1.0, 0.0, 0.0, 0.0], [math.cos(math.pi / 4), math.sin(math.pi / 4), 0.0, 0.0]]
    )

    assert torch.allclose(result, expected, atol=1e-6)


# -----------------------------------------------
# === quaternion_delta tests ===
# -----------------------------------------------


def test_quaternion_delta_identity():
    """Test quaternion delta between identical quaternions."""
    q_from = torch.tensor([[1.0, 0.0, 0.0, 0.0]])
    q_to = torch.tensor([[1.0, 0.0, 0.0, 0.0]])

    result = quaternion_delta(q_from, q_to)
    expected = torch.tensor([[1.0, 0.0, 0.0, 0.0]])  # identity

    assert torch.allclose(result, expected, atol=1e-6)


def test_quaternion_delta_90_degree():
    """Test quaternion delta for 90-degree rotation."""
    q_from = torch.tensor([[1.0, 0.0, 0.0, 0.0]])  # identity
    q_to = torch.tensor(
        [[math.cos(math.pi / 4), math.sin(math.pi / 4), 0.0, 0.0]]
    )  # 90° around X

    result = quaternion_delta(q_from, q_to)
    expected = q_to  # delta from identity to q_to is q_to itself

    assert torch.allclose(result, expected, atol=1e-6)


def test_quaternion_delta_inverse():
    """Test quaternion delta gives inverse rotation."""
    q_from = torch.tensor(
        [[math.cos(math.pi / 4), math.sin(math.pi / 4), 0.0, 0.0]]
    )  # 90° around X
    q_to = torch.tensor([[1.0, 0.0, 0.0, 0.0]])  # identity

    result = quaternion_delta(q_from, q_to)
    # Should be the conjugate of q_from (inverse rotation)
    expected_conjugate = quat_conjugate(q_from)

    assert torch.allclose(result, expected_conjugate, atol=1e-6)


def test_quaternion_delta_batch():
    """Test quaternion delta with batch inputs."""
    q_from = torch.tensor([[1.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 0.0]])
    q_to = torch.tensor(
        [[1.0, 0.0, 0.0, 0.0], [math.cos(math.pi / 4), math.sin(math.pi / 4), 0.0, 0.0]]
    )

    result = quaternion_delta(q_from, q_to)
    expected = torch.tensor(
        [[1.0, 0.0, 0.0, 0.0], [math.cos(math.pi / 4), math.sin(math.pi / 4), 0.0, 0.0]]
    )

    assert torch.allclose(result, expected, atol=1e-6)


def test_quaternion_delta_composition():
    """Test that applying delta gives the target quaternion."""
    q_from = torch.tensor(
        [[math.cos(math.pi / 8), math.sin(math.pi / 8), 0.0, 0.0]]
    )  # 45° around X
    q_to = torch.tensor(
        [[math.cos(math.pi / 4), math.sin(math.pi / 4), 0.0, 0.0]]
    )  # 90° around X

    delta = quaternion_delta(q_from, q_to)
    result = quat_multiply(delta, q_from)

    assert torch.allclose(result, q_to, atol=1e-6)


# -----------------------------------------------
# === Integration tests ===
# -----------------------------------------------


def test_euler_to_quat_roundtrip_consistency():
    """Test that Euler->Quat conversion produces valid quaternions."""
    euler_deg = torch.tensor([[30.0, 45.0, 60.0], [0.0, 90.0, 0.0], [180.0, 0.0, 0.0]])

    quat = euler_deg_to_quat_wxyz(euler_deg)

    # All quaternions should be normalized
    norms = torch.norm(quat, dim=-1)
    assert torch.allclose(norms, torch.ones_like(norms), atol=1e-6)

    # All quaternions should pass sanitization
    for i in range(quat.shape[0]):
        sanitize_quaternion(quat[i : i + 1])


def test_quaternion_operations_consistency():
    """Test consistency between quaternion operations."""
    q1 = torch.tensor(
        [[math.cos(math.pi / 6), math.sin(math.pi / 6), 0.0, 0.0]]
    )  # 60° around X
    q2 = torch.tensor(
        [[math.cos(math.pi / 4), 0.0, math.sin(math.pi / 4), 0.0]]
    )  # 90° around Y

    # Test that q * q^-1 = identity
    q_conj = quat_conjugate(q1)
    identity = quat_multiply(q1, q_conj)
    expected_identity = torch.tensor([[1.0, 0.0, 0.0, 0.0]])

    assert torch.allclose(identity, expected_identity, atol=1e-6)

    # Test that delta composition works
    delta = quaternion_delta(q1, q2)
    result = quat_multiply(delta, q1)

    assert torch.allclose(result, q2, atol=1e-6)
